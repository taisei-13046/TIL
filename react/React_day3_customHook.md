## やったこと
前回、Memo化をまとめる中、useCallbackを扱った  
その際、カスタムフックの話が出てきたので、今回はCustom Hookについて触れたいと思う。  

[公式doc 独自フックの作成](https://ja.reactjs.org/docs/hooks-custom.html)  
自分独自のフックを作成することで、コンポーネントからロジックを抽出して再利用可能な関数を作ることが可能になる。  
#### カスタムフックとは、名前が **”use”** で始まり、ほかのフックを呼び出せる JavaScript の関数のこと  

- 同じフックを使うコンポーネントは state を共有する？ 
  - いいえ。
  - カスタムフックは state を使うロジック（データの購読を登録したり現在の値を覚えておいたり）を共有するためのものですが、
    カスタムフックを使う場所ごとで、内部の state や副作用は完全に分離しています。

### カスタムフックを使うメリット
1. 複数のReact hooksをまとめることができる
2. View(コンポーネント)とロジックが分離できる

### カスタムフックの設計や実装する上で気をつけること
### 1. 戻り値にルールを設ける  
一番個人によってバラバラになりやすいのが、戻り値であり、プロジェクトごとにルールを設けた方がいい。  

パターン1. **React hooksのスタイルに合わせる**  
![スクリーンショット 2021-12-26 13 37 00](https://user-images.githubusercontent.com/78260526/147398986-843a6074-fbae-432c-8ba2-a6c312b46b54.png)  
React hooksにスタイルを合わせるメリット
- 戻り値だけで、どのようなフックであるかある程度予測がつく  
  カスタムフックの処理自体にも統制をとることができる
- 戻り値が肥大化した際に、処理を分割すべきか見直すことができるため

パターン2: **オブジェクトですべて返す**  
返したいものを全てオブジェクトに詰め込んで返すパターン  
オブジェクトで返すのメリット  

- 返却値を増やしたい時に変更がいらない
- コンポーネントで呼び出す際に、返却値の命名が変更されることがない
- テスト時に値を取りやすい (result.current.〇〇でとれる)

### 2. メモ化を意識する
**関数を返すカスタムフックに関してはすべてuseCallbackで囲ってあげるのがよい**

[useCallbackはとにかく使え！　特にカスタムフックでは](https://blog.uhy.ooo/entry/2021-02-23/usecallback-custom-hooks/)  

(例)  
```js
const App: React.VFC = () => {
  const handleClick = useCallback((e: React.MouseEvent) => {
    console.log("clicked!");
  }, []);

  return (
    <button onClick={handleClick}>button</button>
  );
};
```
useCallbackは、初回の呼び出し（Appの初回のレンダリング）では渡された関数をそのまま返す。  
Appが再レンダリングされたとき、useCallbackの返り値としては初回レンダリング時のときの関数オブジェクトが再利用される。  
（useCallbackに渡された関数オブジェクトは今回は捨てられます）  
つまり、handleClickは初回のレンダリング時も2回目のレンダリング時も同じ（===の意味で等しい）関数オブジェクトである。  

### カスタムフックと責務の分離
カスタムフックを作る理由は、普通の関数を作る理由と全く同じであり、すなわち**責務の分離**とか**カプセル化**  
一度カスタムフックとして分離された以上、インターフェースの内側のことはカスタムフック内で完結すべきです。  
カスタムフックを使う側はカスタムフックの内側のことを知るべきではなく、その逆も然りです。  
