## やったこと
[ブラウザの仕組み: 最新ウェブブラウザの内部構造](https://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/#Parsing_general)  
こいつを読んだ！  

### 1. 初めに
#### ブラウザの主な機能
ブラウザの主な機能はユーザーの選択したウェブ リソースをサーバーに要求してブラウザ ウィンドウに表示することにより、ユーザーに提示することです。  
不思議なことに、ブラウザのユーザー インターフェースは正式な仕様では規定されていません。長年の経験から優れた実践手法が形成され、互いに真似し合うことによって生まれたものです。  

#### ブラウザの上位構造
- **ユーザー インターフェース**
  - アドレスバー、戻る/進むボタン、ブックマーク メニューなどがあります。
  - ブラウザ画面のうち、要求したページが表示されるメイン ウィンドウを除くすべての部分です。
- **ブラウザ エンジン**
  - UI とレンダリング エンジンの間の処理を整理します。
- **レンダリング エンジン**
  - 要求されたコンテンツの表示を担当します。
  - たとえば、要求されたコンテンツが HTML の場合は、HTML と CSS を解析し、解析されたコンテンツを画面に表示します。
- **ネットワーキング**
  - HTTP リクエストなどのネットワークの呼び出しに使用されます。
  - プラットフォームに依存しないインターフェースと、プラットフォームごとの下部の実装を備えています。
- **UI バックエンド**
  - コンボ ボックスやウィンドウなどの基本的なウィジェットの描画に使用されます。
  - プラットフォームに依存しない汎用的なインターフェースを公開し、その下ではオペレーティング システムのユーザー インターフェース メソッドを使用しています。
- **JavaScript インタープリタ**
  - JavaScript コードの解析と実行に使用されます。
- **データ ストレージ**
  - 永続的なレイヤです。
  - ブラウザでは Cookie などさまざまなデータをハード ディスクに保存する必要があります。
  - 新しい HTML 仕様（HTML5）では、ブラウザ内の完全で軽量なデータベースである「ウェブ データベース」が定義されています。
 
 ![スクリーンショット 2022-02-02 9 53 41](https://user-images.githubusercontent.com/78260526/152076073-58097154-55b3-483a-bb9f-ce7c3ae1bc93.png)  
 
 #### レンダリング エンジン
レンダリング エンジンの仕事は「レンダリング」、つまり、要求されたコンテンツをブラウザの画面に表示することです。  
参考ブラウザの Firefox、Chrome、Safari は 2 つのレンダリング エンジン上に構築されています。  
Safari と Chrome では Webkit を使用しています。  

レンダリング エンジンはまず、要求したドキュメントのコンテンツをネットワーキング レイヤから取得します。この処理は 8 キロバイト単位で行われます。  
レンダリング エンジンのその後の基本的なフローは次のとおりです。  
![スクリーンショット 2022-02-02 10 01 38](https://user-images.githubusercontent.com/78260526/152076819-dec8ad89-5096-4cf9-b27b-3e13a8e37f53.png)  

1. **レンダリング エンジンは HTML ドキュメントの解析を開始し、タグを「コンテンツ ツリー」というツリー内の DOM ノードに変換します。**  
  外部の CSS ファイルと style 要素内のスタイル データを解析します。スタイル情報と HTML 内の視覚的な指示を組み合わせて、「レンダー ツリー」という別のツリーが作成されます。  
2. **レンダー ツリーが構築されると、「レイアウト」処理に進みます。**  
  つまり、画面に表示される正確な座標が各ノードに割り当てられます。  
3. **次の段階は「描画」です。**  
  レンダー ツリーが走査され、UI バックエンド レイヤを使用して各ノードが描画されます。  

#### 解析
解析はレンダリング エンジンの中で非常に重要な処理  
ドキュメントの解析とは、ドキュメントを意味のある構造（コード内で解釈し、使用できる形式）に変換することです。  
例 -「2 + 3 - 1」という式を解析すると、次のようなツリーが返されます。   
  
![スクリーンショット 2022-02-02 10 07 19](https://user-images.githubusercontent.com/78260526/152077290-cfdd6d8f-59d4-42ac-b39d-839a25204426.png)  

##### パーサーとレキサーの連携
解析は「字句解析」と「構文解析」の 2 つのサブプロセスに分けることができます。  
字句解析は、入力をトークンに分割する処理です。トークンは言語の語彙（有効な構成要素の集まり）に相当します。  
構文解析は、言語の構文ルールを適用することです。  
通常、パーサーでは処理を 2 つの構成要素に分けて行います。入力を有効なトークンに分割する「レキサー」（または「トークナイザー」）と、言語の構文ルールに従ってドキュメントの構造を分析し、解析ツリーを構築する「パーサー」です。  

##### パーサーの種類
パーサーには、「トップダウン パーサー」と「ボトムアップ パーサー」という 2 つの基本的な種類があります。  
- トップダウン パーサーは構文の上位構造を調べて、いずれかの構文ルールと一致させようとします。
- ボトムアップ パーサーはまず入力を調べて、段階的に構文ルールに変換していきます。

#### 解析アルゴリズム
HTML は通常のトップダウン パーサーやボトムアップ パーサーでは解析できません。  
その理由は次のとおりです。  
1. 言語の寛容な性質。  
2. 無効な HTML のよく知られたケースに対応するため、ブラウザでこれまでエラーが許容されてきたこと。
3. 解析処理が「再入可能（リエントラント）」であること。通常は解析中にソースが変更されることはありませんが、HTML では、「document.write」を含むスクリプト タグによってさらにトークンが追加される場合があるため、実際には解析処理中に入力が変更されます。

アルゴリズムは「トークン化」と「ツリー構築」の 2 段階で構成されています。  
トークン化は字句解析であり、入力を解析してトークンに分割します。HTML トークンには、開始タグ、終了タグ、属性名、属性値などがあります。  
トークナイザーはトークンを識別し、ツリー コンストラクタに渡すと、次のトークンを識別するために次の文字を処理します。これを入力の最後まで続けます。  
![スクリーンショット 2022-02-02 10 53 30](https://user-images.githubusercontent.com/78260526/152081165-103672b1-6073-4f7b-a362-973bdb50dca7.png)  

##### トークン化アルゴリズム
このアルゴリズムの出力は HTML トークンです。アルゴリズムはステート マシン（状態マシン）として表現されます。  
したの例をトークン化してみる  
```html
<html>
  <body>
    Hello world
  </body>
</html>
```
1. 最初の状態は「**データ状態**」です。`<` 文字に遭遇すると、状態は「**タグ開始状態**」に変わります。
2. a-z 文字を読み込むと「開始タグ トークン」の作成が始まり、状態は「タグ名状態」に変わります。 
3. `>` タグに達すると、現在のトークンが出力され、状態は再び「データ状態」に変わります。
4. 次の入力 `/` を読み込むと「終了タグトークン」の作成が始まり、「タグ名状態」に移ります。
5. 再び、> に達するまでこの状態に留まります。新しいタグ トークンが出力されると「データ状態」に戻ります。

##### ツリー構築アリゴリズム
パーサーの作成時に Document オブジェクトが作成されます。ツリー構築段階で、ルートに Document を持つ DOM ツリーが変更され、要素が追加されていきます。  
上の例でもう一度見ていく  

1. ツリー構築段階への入力はトークン化段階からの一連のトークンです。最初のモードは「initial」モードです。
2. html トークンを受け取ると「before html」モードに移り、そのモードでトークンの再処理が行われます。
3. モードは「before head」に変わります。次に body トークンを受け取ります。
4. トークン名は「head」ではありませんが、暗黙的に HTMLHeadElement が作成され、ツリーに追加されます。
5. ここで「in head」モードに移り、次に「after head」モードに移ります。
6. body トークンが再処理され、HTMLBodyElement が作成および挿入されると、モードは「in body」に移ります。
7. body end トークンを受け取ると、「after body」モードに移ります。html end トークンを受け取ると、「after after body」モードに移ります。
8. end of file トークンを受け取ると解析が終了します。






 
 
 
 
 
 
