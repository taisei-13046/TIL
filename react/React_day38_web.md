## やったこと
[ブラウザの仕組み: 最新ウェブブラウザの内部構造](https://www.html5rocks.com/ja/tutorials/internals/howbrowserswork/#Parsing_general)  
こいつを読んだ！  

### 1. 初めに
#### ブラウザの主な機能
ブラウザの主な機能はユーザーの選択したウェブ リソースをサーバーに要求してブラウザ ウィンドウに表示することにより、ユーザーに提示することです。  
不思議なことに、ブラウザのユーザー インターフェースは正式な仕様では規定されていません。長年の経験から優れた実践手法が形成され、互いに真似し合うことによって生まれたものです。  

#### ブラウザの上位構造
- **ユーザー インターフェース**
  - アドレスバー、戻る/進むボタン、ブックマーク メニューなどがあります。
  - ブラウザ画面のうち、要求したページが表示されるメイン ウィンドウを除くすべての部分です。
- **ブラウザ エンジン**
  - UI とレンダリング エンジンの間の処理を整理します。
- **レンダリング エンジン**
  - 要求されたコンテンツの表示を担当します。
  - たとえば、要求されたコンテンツが HTML の場合は、HTML と CSS を解析し、解析されたコンテンツを画面に表示します。
- **ネットワーキング**
  - HTTP リクエストなどのネットワークの呼び出しに使用されます。
  - プラットフォームに依存しないインターフェースと、プラットフォームごとの下部の実装を備えています。
- **UI バックエンド**
  - コンボ ボックスやウィンドウなどの基本的なウィジェットの描画に使用されます。
  - プラットフォームに依存しない汎用的なインターフェースを公開し、その下ではオペレーティング システムのユーザー インターフェース メソッドを使用しています。
- **JavaScript インタープリタ**
  - JavaScript コードの解析と実行に使用されます。
- **データ ストレージ**
  - 永続的なレイヤです。
  - ブラウザでは Cookie などさまざまなデータをハード ディスクに保存する必要があります。
  - 新しい HTML 仕様（HTML5）では、ブラウザ内の完全で軽量なデータベースである「ウェブ データベース」が定義されています。
 
 ![スクリーンショット 2022-02-02 9 53 41](https://user-images.githubusercontent.com/78260526/152076073-58097154-55b3-483a-bb9f-ce7c3ae1bc93.png)  
 
 #### レンダリング エンジン
レンダリング エンジンの仕事は「レンダリング」、つまり、要求されたコンテンツをブラウザの画面に表示することです。  
参考ブラウザの Firefox、Chrome、Safari は 2 つのレンダリング エンジン上に構築されています。  
Safari と Chrome では Webkit を使用しています。  

レンダリング エンジンはまず、要求したドキュメントのコンテンツをネットワーキング レイヤから取得します。この処理は 8 キロバイト単位で行われます。  
レンダリング エンジンのその後の基本的なフローは次のとおりです。  
![スクリーンショット 2022-02-02 10 01 38](https://user-images.githubusercontent.com/78260526/152076819-dec8ad89-5096-4cf9-b27b-3e13a8e37f53.png)  

1. **レンダリング エンジンは HTML ドキュメントの解析を開始し、タグを「コンテンツ ツリー」というツリー内の DOM ノードに変換します。**  
  外部の CSS ファイルと style 要素内のスタイル データを解析します。スタイル情報と HTML 内の視覚的な指示を組み合わせて、「レンダー ツリー」という別のツリーが作成されます。  
2. **レンダー ツリーが構築されると、「レイアウト」処理に進みます。**  
  つまり、画面に表示される正確な座標が各ノードに割り当てられます。  
3. **次の段階は「描画」です。**  
  レンダー ツリーが走査され、UI バックエンド レイヤを使用して各ノードが描画されます。  

#### 解析
解析はレンダリング エンジンの中で非常に重要な処理  
ドキュメントの解析とは、ドキュメントを意味のある構造（コード内で解釈し、使用できる形式）に変換することです。  
例 -「2 + 3 - 1」という式を解析すると、次のようなツリーが返されます。   
  
![スクリーンショット 2022-02-02 10 07 19](https://user-images.githubusercontent.com/78260526/152077290-cfdd6d8f-59d4-42ac-b39d-839a25204426.png)  

##### パーサーとレキサーの連携
解析は「字句解析」と「構文解析」の 2 つのサブプロセスに分けることができます。  
字句解析は、入力をトークンに分割する処理です。トークンは言語の語彙（有効な構成要素の集まり）に相当します。  
構文解析は、言語の構文ルールを適用することです。  
通常、パーサーでは処理を 2 つの構成要素に分けて行います。入力を有効なトークンに分割する「レキサー」（または「トークナイザー」）と、言語の構文ルールに従ってドキュメントの構造を分析し、解析ツリーを構築する「パーサー」です。  

##### パーサーの種類
パーサーには、「トップダウン パーサー」と「ボトムアップ パーサー」という 2 つの基本的な種類があります。  
- トップダウン パーサーは構文の上位構造を調べて、いずれかの構文ルールと一致させようとします。
- ボトムアップ パーサーはまず入力を調べて、段階的に構文ルールに変換していきます。

#### 解析アルゴリズム
HTML は通常のトップダウン パーサーやボトムアップ パーサーでは解析できません。  
その理由は次のとおりです。  
1. 言語の寛容な性質。  
2. 無効な HTML のよく知られたケースに対応するため、ブラウザでこれまでエラーが許容されてきたこと。
3. 解析処理が「再入可能（リエントラント）」であること。通常は解析中にソースが変更されることはありませんが、HTML では、「document.write」を含むスクリプト タグによってさらにトークンが追加される場合があるため、実際には解析処理中に入力が変更されます。

アルゴリズムは「トークン化」と「ツリー構築」の 2 段階で構成されています。  
トークン化は字句解析であり、入力を解析してトークンに分割します。HTML トークンには、開始タグ、終了タグ、属性名、属性値などがあります。  
トークナイザーはトークンを識別し、ツリー コンストラクタに渡すと、次のトークンを識別するために次の文字を処理します。これを入力の最後まで続けます。  
![スクリーンショット 2022-02-02 10 53 30](https://user-images.githubusercontent.com/78260526/152081165-103672b1-6073-4f7b-a362-973bdb50dca7.png)  

##### トークン化アルゴリズム
このアルゴリズムの出力は HTML トークンです。アルゴリズムはステート マシン（状態マシン）として表現されます。  
したの例をトークン化してみる  
```html
<html>
  <body>
    Hello world
  </body>
</html>
```
1. 最初の状態は「**データ状態**」です。`<` 文字に遭遇すると、状態は「**タグ開始状態**」に変わります。
2. a-z 文字を読み込むと「開始タグ トークン」の作成が始まり、状態は「タグ名状態」に変わります。 
3. `>` タグに達すると、現在のトークンが出力され、状態は再び「データ状態」に変わります。
4. 次の入力 `/` を読み込むと「終了タグトークン」の作成が始まり、「タグ名状態」に移ります。
5. 再び、> に達するまでこの状態に留まります。新しいタグ トークンが出力されると「データ状態」に戻ります。

##### ツリー構築アリゴリズム
パーサーの作成時に Document オブジェクトが作成されます。ツリー構築段階で、ルートに Document を持つ DOM ツリーが変更され、要素が追加されていきます。  
上の例でもう一度見ていく  

1. ツリー構築段階への入力はトークン化段階からの一連のトークンです。最初のモードは「initial」モードです。
2. html トークンを受け取ると「before html」モードに移り、そのモードでトークンの再処理が行われます。
3. モードは「before head」に変わります。次に body トークンを受け取ります。
4. トークン名は「head」ではありませんが、暗黙的に HTMLHeadElement が作成され、ツリーに追加されます。
5. ここで「in head」モードに移り、次に「after head」モードに移ります。
6. body トークンが再処理され、HTMLBodyElement が作成および挿入されると、モードは「in body」に移ります。
7. body end トークンを受け取ると、「after body」モードに移ります。html end トークンを受け取ると、「after after body」モードに移ります。
8. end of file トークンを受け取ると解析が終了します。

### CSS の解析
HTML とは異なり、CSS は文脈自由文法なので、概要で述べた種類のパーサーを使って解析することができます。  
CSS 仕様（英語）では、CSS の語彙文法と構文文法を定義しています。  
以下のような例の場合は
```css
div.error , a.error {
  color:red;
  font-weight:bold;
}
```
ルールセットはこのようになっている
```
ruleset
  : selector [ ',' S* selector ]*
    '{' S* declaration [ ';' S* declaration ]* '}' S*
  ;
```

#### Webkit の CSS パーサー
Webkit では Flex と Bison パーサー ジェネレータを使用して、CSS 文法ファイルからパーサーを自動的に作成します。  

![スクリーンショット 2022-02-02 11 09 38](https://user-images.githubusercontent.com/78260526/152082488-51d689a6-d7cf-4c00-b85d-3cff19a5ce79.png)  

#### スクリプトとスタイル シートの処理順序
**スクリプト**の場合  
ウェブのモデルは同期的です。制作者は、パーサーが `<script>` タグに達するとすぐにスクリプトが解析、実行されると想定しています。ドキュメントの解析はスクリプトが実行されるまで中断されます。  

**投機的な解析**  
Webkit と Firefox のいずれもこの最適化を行っています。スクリプトの実行中に別のスレッドでドキュメントの残りを解析し、ネットワークから読み込む必要のある他のリソースを探して、読み込みます。このようにリソースの読み込みを並列接続上で行うため、全体的な速度が向上します。  

**スタイル シート**  
一方、スタイル シートは異なるモデルです。理論的には、スタイル シートは DOM ツリーを変更しないため、スタイル シートの読み込みを待ってドキュメントの解析を中断する理由はないように思われます。しかし、ドキュメントの解析段階でスクリプトがスタイル情報を要求するという問題があります。スタイルの読み込みと解析がまだ済んでいない場合、スクリプトは誤った回答を受け取ることになり、さまざまな問題を引き起こす可能性があります。これは特殊なケースのように見えますが、実際にはよく起きています。  


#### レンダー ツリーの構築
DOM ツリーを構築する間に、ブラウザは「レンダー ツリー」という別のツリーも構築します。このツリーは、視覚的な要素を表示順に並べたツリーであり、ドキュメントの視覚的な表現です。レンダー ツリーの目的は、コンテンツを正しい順序で描画できるようにすることです。  
Webkit のレンダラーの基本クラスである RenderObject クラスは次のように定義されています。  
```c++
class RenderObject{
  virtual void layout();
  virtual void paint(PaintInfo);
  virtual void rect repaintRect();
  Node* node;  //the DOM node
  RenderStyle* style;  // the computed style
  RenderLayer* containgLayer; //the containing z-index layer
}
```

ボックスの種類は、そのノードに関連する「display」スタイル属性に影響されます  
次の Webkit のコードは、DOM ノードに対してどの種類のレンダラーを作成するかを display 属性に従って決定するコードです。  
```c++
RenderObject* RenderObject::createObject(Node* node, RenderStyle* style)
{
    Document* doc = node->document();
    RenderArena* arena = doc->renderArena();
    ...
    RenderObject* o = 0;

    switch (style->display()) {
        case NONE:
            break;
        case INLINE:
            o = new (arena) RenderInline(node);
            break;
        case BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case INLINE_BLOCK:
            o = new (arena) RenderBlock(node);
            break;
        case LIST_ITEM:
            o = new (arena) RenderListItem(node);
            break;
       ...
    }

    return o;
}
```

#### レンダー ツリーと DOM ツリーの関係
レンダラーは DOM 要素に対応していますが、その関係は 1 対 1 ではありません。視覚的でない DOM 要素はレンダー ツリーに挿入されません。その例として「head」要素が挙げられます。display 属性に「none」が指定されている要素もツリーには含まれません（visibility 属性に「hidden」が指定された要素はツリーに含まれます）。  

##### ツリー構築のフロー
Webkit では、スタイルを解決してレンダラーを作成する処理を「関連付け（attachment）」といいます。各 DOM ノードには「attach」メソッドがあります。関連付けは同期的に行われ、DOM ツリーにノードが挿入されると、新しいノードの「attach」メソッドが呼び出されます。  
html タグと body タグを処理すると、レンダー ツリーのルートが構築されます。ルートのレンダー オブジェクトは CSS 仕様で「包含ブロック」と呼ばれるものに相当します（他のすべてのブロックを含む最上位のブロックです）。その寸法はビューポート（ブラウザ ウィンドウの表示領域の寸法）です。  

レンダー ツリーを構築するには、各レンダー オブジェクトの視覚的プロパティを計算する必要があります。この処理は各要素のスタイル プロパティを計算することで行います。  
スタイルの計算にはいくつかの問題点があります。
1. スタイル データは多数のスタイル プロパティを含む非常に大きな構造体なので、メモリの問題が起きる可能性があります。
2. 最適化されていない場合、要素ごとにマッチング ルールを探索すると、パフォーマンスの問題が起きる可能性があります。
3. 適用するルールには、ルールの階層を定義した非常に複雑なカスケード ルールもあります。

Webkit のノードはスタイル オブジェクト（RenderStyle）を参照しています。条件によっては、複数のノードでこのオブジェクトを共有することができます。  
ノードが「兄弟」か「いとこ」の関係にあり、要素が次の条件に該当する場合です。  
1. マウスの状態が同じ（たとえば、一方が「:hover」で、もう一方が「:hover」でない場合は該当しない）。
2. いずれの要素にも id がない。
3. タグ名が一致する。
4. クラス属性が一致する。
5. マッピングされた属性のセットが同一である。
6. リンクの状態が一致する。
7. フォーカスの状態が一致する。
8. いずれの要素も属性セレクタの影響を受けていない。「影響を受ける」とは、セレクタ内のどこかに属性セレクタを使用しているセレクタの照合がある場合です。
9. 要素にインラインのスタイル属性がない。
10. 「兄弟」セレクタがまったく使用されていない。WebCore では、兄弟セレクタに遭遇した場合は単にグローバル スイッチを送出し、表示時のドキュメント全体のスタイル共有を無効にします。これには + セレクタ、「:first-child」や「:last-child」などのセレクタがあります。
 
 
 
 
 
 
