## やったこと
roadmapを進めた

### Internet, `what is HTTP?`
MDNの資料を読んだ  
[HTTP](https://developer.mozilla.org/ja/docs/Web/HTTP)   

Hypertext Transfer Protocol (HTTP) は HTML などのハイパーメディア文書を転送するためのアプリケーション層プロトコル  
HTTP はいわゆるステートレスプロトコルであり、つまりサーバーは二つのリクエスト間で何もデータを保持しません。  

![スクリーンショット 2022-01-31 15 55 10](https://user-images.githubusercontent.com/78260526/151751036-d2362418-6c45-40df-af41-abc0907ce2c8.png)  
> 1990 年代初頭に設計された HTTP は、時間をかけて進化した拡張可能なプロトコルです。 HTTP は、 TCP または TLS (暗号化された TCP 接続) を使用して送信されるアプリケーション層のプロトコルですが、理論上は信頼性のある任意のトランスポート層プロトコルを使用できます。  

#### HTTPベースシステムの構成要素
個々のリクエストはサーバーに送信され、処理した後にレスポンスと呼ばれる回答を提供します。  
クライアントとサーバーとの間には、例えばゲートウェイやキャッシュなどの様々な操作を行う、まとめてプロキシサーバーと呼ばれるいくつもの実体が存在しています。  

![スクリーンショット 2022-01-31 15 57 25](https://user-images.githubusercontent.com/78260526/151751231-57a8959c-a804-4502-8cd9-9acf4eb1fc8f.png)  

- **クライアント: ユーザーエージェント**
  - ユーザーエージェントは、ユーザのために働くツールです。この役割は主に、ウェブブラウザーが担います。
  - ブラウザーは常に、リクエストを生成する実体です。サーバーにはなりません
  - ウェブページは、ハイパーテキスト文書です。これは表示されているテキストの一部が新たなウェブページの取り込みを (通常、マウスのクリックによって) 発生させるリンクであり、ユーザーがユーザーエージェントを導いてウェブ内を移動できるということです。
- **ウェブサーバー**
  - 通信路の反対側は、クライアントのリクエストに応じて文書を提供するサーバーがいます。
  - サーバーは 1 台のマシンである必要性はありませんが、複数のサーバーのソフトウェアインスタンスを同じマシンで運用することができます。 HTTP/1.1 と Host ヘッダーによって、同じ IP アドレスを共有できます。
- **プロキシ**
  - ウェブブラウザーとウェブサーバーの間では、多数のコンピューターや端末が HTTP メッセージを中継します。
  - プロキシの機能
    - キャッシュ (キャッシュは共用、あるいはブラウザーキャッシュのように個人用にできます)
    - フィルタリング (アンチウィルススキャンやペアレンタルコントロールなど)
    - 負荷分散 (複数のサーバーが別々のリクエストに対応できるようにする)
    - 認証 (さまざまなリソースへのアクセスを制御する)
    - ログ記録 (履歴情報の保管を可能にする)  

#### HTTP の基本方針
- **HTTP はシンプル**
  - HTTP/2 で HTTP メッセージをフレームにカプセル化することにより複雑さが増しましたが、 HTTP は全体的にシンプルで人間が読めるように設計されています。 
- **HTTP は拡張可能**
  - HTTP/1.0 で導入された HTTP ヘッダーによって、プロトコルの拡張や実験が容易になっています。
- **HTTP はステートレスであるがセッションレスではない**
  - HTTP はステートレスです。同じコネクション上であっても、連続的に実行される 2 つのリクエスト間に関係性はありません。
    - ステートフルとは、システムが現在の状態を表すデータなどを保持しており、その内容を処理に反映させる方式。
  - しかし HTTP の核心がステートレスであっても、 HTTP Cookie によってステートフルなセッションを実現できます。
- **HTTP とコネクション**
  - HTTP/1.1 でパイプライン (実装が難しいことが立証されました) や持続的接続を導入しました。 Connection ヘッダーを使用して、下層の TCP コネクションを部分的に制御できます。 
  - HTTP/2 はひとつのコネクションで複数のメッセージを多重化するように進化しました。コネクションををウォーム状態に保つのに役立ち、効率が向上します。

#### HTTP が制御できること
- **キャッシュ**
  - サーバーはプロキシやクライアントに対して、何をどれだけの間キャッシュするかを指示できます。
  - クライアントは中間のキャッシュプロキシに対して、保存されている文書を無視するよう指示できます。
- **オリジン制約の緩和**
  - 同一オリジンのページだけが、ウェブページの情報すべてにアクセスできます。この制約はサーバーにとって負担になりますが、 HTTP ヘッダーでサーバー側の厳密な分割を緩和できます。
- **認証**
  - 基本的な認証は HTTP が提供しており、 WWW-Authenticate などのヘッダーを使用するか、 HTTP Cookie を使用した特別なセッションを設定する
- **プロキシとトネリング**
  - [プロキシサーバーとトンネリング](https://developer.mozilla.org/ja/docs/Web/HTTP/Proxy_servers_and_tunneling)  
  インターネットのさまざまなネットワークを移動するときに、プロキシサーバーと HTTP トンネルは、 World Wide Web 上のコンテンツへのアクセスを容易にしています。  
  プロキシには、フォワードプロキシ (またはトンネルまたはゲートウェイ) とリバースプロキシ (負荷分散、認証、復号化またはキャッシュ用のサーバーへのアクセスを制御および保護するために使用される) の2種類があります。  
  ##### HTTP トンネリング
  トンネリングはデータをカプセル化することによって、パブリックネットワークを介してプライベートネットワークデータおよびプロトコル情報を送信します。  
  HTTP トンネリングは、より低いレベルのプロトコル (TCP) を伝送するために、より高いレベル (HTTP) のプロトコルを使用しています。  
  HTTP プロトコルは CONNECT と呼ばれるリクエストメソッドを指定します。リクエストされたリソースとの双方向通信を開始し、トンネルを開くために使用することができます。  
- **セッション**
  - HTTP Cookie を使用して、リクエストとサーバーのセッションを関連付けできます。これにより HTTP がステートレスプロトコルであるにもかかわらず、セッションを作成できます。

#### HTTP のフロー
クライアントがサーバー (最終目的地のサーバーまたは中間のプロキシ) と通信したいとき、クライアントは以下の段階を踏みます。  
1. **TCP コネクションを開く:**
クライアントは新しいコネクションを開く、既存のコネクションを再使用する、あるいはサーバーに対して複数の TCP コネクションを開くことができます。  
2. **HTTP メッセージを送信する**
3. **サーバーから送信されたレスポンスを読み取る**
4. **次のリクエストのために、コネクションを閉じるか再使用する**

HTTP パイプラインが有効である場合は、最初のレスポンスが完全に返るのを待たずに複数のリクエストを送信できます。   
HTTP パイプラインは、 HTTP/2 でフレーム内にリクエストを強力に多重化する機能によって置き換えられました。  

#### HTTP メッセージ
HTTP/1.1 以前の HTTP メッセージは、人間が読むことができます。 HTTP/2 ではこれらのメッセージがバイナリ構造のフレームに埋め込まれており、ヘッダーの圧縮や多重化といった最適化が可能になりました。本来の HTTP メッセージの部分だけがこのバージョンの HTTP で送信されていても、各メッセージの意味は変わっておらず、クライアントは本来の HTTP/1.1 メッセージを (事実上) 再構成します。したがって、 HTTP/2 メッセージを HTTP/1.1 形式で理解することは役に立ちます。  

リクエスト  
![スクリーンショット 2022-01-31 17 25 24](https://user-images.githubusercontent.com/78260526/151760858-4aa917a8-bda9-4ecd-8889-bb843f1de16a.png)  
- HTTP メソッド
- 取り込むリソースのパス
  - 状況から明らかであればリソースの URL はこの要素から取り除かれます。  
  - たとえばプロトコル (http://)、ドメイン (ここでは developer.mozilla.org)、TCP ポート (ここでは 80) が取り除かれます。  
- HTTP プロトコルのバージョン
- サーバーに追加の情報を与える任意のヘッダー

レスポンス  
![スクリーンショット 2022-01-31 17 30 14](https://user-images.githubusercontent.com/78260526/151761523-c00615a7-11d6-4629-9738-78ec1ff24c1a.png)  
- 準拠する HTTP プロトコルのバージョン。
- ステータスコード。
  - リクエストが成功したか否か、およびその理由を示します。
- ステータスメッセージ。
  - ステータスコードの簡単な説明ですが、権威はありません。
- リクエストと同様の HTTP ヘッダー。
- (省略可) リソースを含む本文。

### HTTP キャッシュ
キャッシュは、提供されたリソースの複製を保存して、要求されたときに背後でその複製を提供する技術です。  
ウェブキャッシュのストア内に要求されたリソースがあるとき、キャッシュはリクエストに介入して、提供元のサーバーから再びダウンロードする代わりにキャッシュ内の複製を返します。  
キャッシュにはさまざまな種類があり、これらはプライベートキャッシュと共有キャッシュの 2 つのカテゴリーに大きく分類できます。  

- 共有キャッシュ
  - 複数のユーザーが再使用するためにレスポンスを保存するキャッシュ
- プライベートキャッシュ
  - ひとりのユーザーのためのキャッシュ

HTTP キャッシュは必須ではありませんが、キャッシュしたリソースの再使用は通常望ましいことです。  
ただし一般的な HTTP キャッシュはたいてい、GET のレスポンスのみキャッシュするよう制限されており、他のメソッドではキャッシュしません。  
キャッシュ項目の一般的な形式は以下のとおり  
- 取得要求に成功した結果: GET リクエストに対する 200 (OK) レスポンスには、HTML 文書、画像、ファイルなどのリソースが含まれています。
- 恒久的なリダイレクト: 301 (Moved Permanently) レスポンス。
- エラーレスポンス: 404 (Not Found) のページ。
- 不完全な結果: 206 (Partial Content) レスポンス。
- キャッシュのキーとして使用することが適切であると定義されていれば、GET 以外のレスポンス。

#### キャッシュを制御する
**`Cache-Control` ヘッダー**  
- キャッシュしない
  ```
  Cache-Control: no-store
  ```
- キャッシュするが再検証する
  - キャッシュした複製を渡す前に検証のため、キャッシュは生成元のサーバーにリクエストを送信します。
  ```
  Cache-Control: no-cache
  ```
- private キャッシュと public キャッシュ
  - "public" ディレクティブは、どのキャッシュでもレスポンスを保存してよいことを示します。  
    これは、通常はキャッシュできない HTTP 認証やレスポンスステータスコードを伴うページをキャッシュしなければならない時に有用です。
  - "private" はレスポンスがひとりのユーザーのためのものであり、共有キャッシュに保存してはならないことを示します。
  ```
  Cache-Control: private
  Cache-Control: public
  ```
- 有効期限
  - このヘッダーでもっとも重要なディレクティブが、リソースが陳腐化していないと考えられる最長期間を表す `"max-age=<seconds>"` です  
  ```
  Cache-Control: max-age=31536000
  ```
- 検証
  - "must-revalidate" ディレクティブを使用すると、キャッシュはリソースを使用する前に陳腐化の状態を検証しなければならず、また期限切れのリソースを使用するべきではありません。  
  ```
  Cache-Control: must-revalidate
  ```

#### 鮮度

リソースがキャッシュに保存されると、理論上は永久にキャッシュからリソースを提供することができます。  
キャッシュは有限の記憶領域ですので、アイテムは定期的に記憶領域から削除されます。この処理はキャッシュ・エビクションと呼ばれます。  

鮮度の寿命は、いくつかのヘッダーを基に計算されます。"Cache-Control: max-age=N" ヘッダーが指定された場合は、鮮度の寿命が N に等しくなります。  

そうでない場合は
```
expirationTime = responseTime + freshnessLifetime - currentAge
```
のように計算される

#### Revving を適用したリソース
キャッシュされたリソースをより多く使用すると、ウェブサイトの応答性やパフォーマンスが向上するでしょう。この最適化のために、有効期限をできるだけ遠い未来にすることが推奨されています。この方法は定期的あるいはよく更新されるリソースでも使用できますが、まれにしか更新されないリソースでは問題があります。  
ウェブ開発者は、Steve Souders 氏が revvingと呼ぶ技術を発明しました。あまり更新しないファイルは、特定の方法で命名します。その方法とは、通常はファイル名である URL にリビジョン (またはバージョン) 番号を追加することです。  
この方法ではそれぞれの新しいリビジョンのリソースが変更されないリソースであるとみなされて、通常は 1 年あるいはそれ以上先の遠い未来を有効期限にすることができます。  

#### キャッシュの検証
キャッシュされた文書の有効期限に達すると、検証または再取得を行います。キャッシュの検証は、サーバーが `strong validator` または `weak validator` を提供していれば実行できます。  
ユーザーが再読み込みボタンを押すと、再検証が発生します。キャッシュされたレスポンスに "Cache-Control: must-revalidate" ヘッダーが含まれている場合は、通常のブラウジングでも再確認が発生します。  

### Cookieについて
HTTP Cookie (ウェブ Cookie、ブラウザー Cookie) は、サーバーがユーザーのウェブブラウザーに送信する小さなデータであり、ブラウザーに保存され、その後のリクエストと共に同じサーバーへ返送されます。  
Cookie は主に、以下の 3 つの用途で使用されます。  
- セッション管理
- パーソナライゼーション
- トラッキング

#### Cookie の作成
HTTP リクエストを受け取った後、サーバーはレスポンスで Set-Cookie ヘッダーを送信することができます。通常 Cookie はブラウザーに保存され、また Cookie は同じサーバーに対して行われるリクエストと共に HTTP の Cookie ヘッダーの中で送信されます。  
単純な Cookie は次のように設定されます。  
```
Set-Cookie: <cookie-name>=<cookie-value>
```
また、そのサーバーへのその後のすべてのリクエストにおいて、ブラウザーは以前格納されたすべてのクッキーを、 Cookie ヘッダーを使用してサーバーへ送信します。  

#### Cookie の持続時間の定義
Cookie の持続時間は2通りの方法で定義することができます。
- セッション Cookie は現在のセッションが終了すると削除されます。
- 持続的 Cookie は、 Expires 属性で指定された時刻、または Max-Age で指定された期間が経過した後に削除されます。 

#### Cookie へのアクセス制限
クッキーが安全に送信され、意図しない第三者やスクリプトからアクセスされないようにするには、 `Secure 属性`と `HttpOnly 属性`の2つの方法があります。  
- Secure 属性がついたクッキーは HTTPS プロトコル上の暗号化されたリクエストでのみサーバーに送信され、安全でない HTTP では決して送信されないため、中間者攻撃者が簡単にアクセスすることはできません。(URL に http: を含む) 安全でないサイトは、 Secure 属性を使用してクッキーを設定することができません。 
- HttpOnly 属性を持つクッキーは、JavaScript の Document.cookie API にはアクセスできません。サーバーに送信されるだけです。例えば、サーバー側のセッションを持続させるクッキーは JavaScript が利用する必要はないので、 HttpOnly 属性をつけるべきです。この予防策は、クロスサイトスクリプティング (XSS) 攻撃を緩和するのに役立ちます。  

#### Cookie の送信先の定義
Domain および Path 属性は、Cookie のスコープ、つまり Cookie を送信する対象の URL を定義します。  
- `Domain 属性`
  - 







