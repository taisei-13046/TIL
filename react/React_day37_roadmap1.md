## やったこと
roadmapを進めた

### Internet, `what is HTTP?`
MDNの資料を読んだ  
[HTTP](https://developer.mozilla.org/ja/docs/Web/HTTP)   

Hypertext Transfer Protocol (HTTP) は HTML などのハイパーメディア文書を転送するためのアプリケーション層プロトコル  
HTTP はいわゆるステートレスプロトコルであり、つまりサーバーは二つのリクエスト間で何もデータを保持しません。  

![スクリーンショット 2022-01-31 15 55 10](https://user-images.githubusercontent.com/78260526/151751036-d2362418-6c45-40df-af41-abc0907ce2c8.png)  
> 1990 年代初頭に設計された HTTP は、時間をかけて進化した拡張可能なプロトコルです。 HTTP は、 TCP または TLS (暗号化された TCP 接続) を使用して送信されるアプリケーション層のプロトコルですが、理論上は信頼性のある任意のトランスポート層プロトコルを使用できます。  

#### HTTPベースシステムの構成要素
個々のリクエストはサーバーに送信され、処理した後にレスポンスと呼ばれる回答を提供します。  
クライアントとサーバーとの間には、例えばゲートウェイやキャッシュなどの様々な操作を行う、まとめてプロキシサーバーと呼ばれるいくつもの実体が存在しています。  

![スクリーンショット 2022-01-31 15 57 25](https://user-images.githubusercontent.com/78260526/151751231-57a8959c-a804-4502-8cd9-9acf4eb1fc8f.png)  

- **クライアント: ユーザーエージェント**
  - ユーザーエージェントは、ユーザのために働くツールです。この役割は主に、ウェブブラウザーが担います。
  - ブラウザーは常に、リクエストを生成する実体です。サーバーにはなりません
  - ウェブページは、ハイパーテキスト文書です。これは表示されているテキストの一部が新たなウェブページの取り込みを (通常、マウスのクリックによって) 発生させるリンクであり、ユーザーがユーザーエージェントを導いてウェブ内を移動できるということです。
- **ウェブサーバー**
  - 通信路の反対側は、クライアントのリクエストに応じて文書を提供するサーバーがいます。
  - サーバーは 1 台のマシンである必要性はありませんが、複数のサーバーのソフトウェアインスタンスを同じマシンで運用することができます。 HTTP/1.1 と Host ヘッダーによって、同じ IP アドレスを共有できます。
- **プロキシ**
  - ウェブブラウザーとウェブサーバーの間では、多数のコンピューターや端末が HTTP メッセージを中継します。
  - プロキシの機能
    - キャッシュ (キャッシュは共用、あるいはブラウザーキャッシュのように個人用にできます)
    - フィルタリング (アンチウィルススキャンやペアレンタルコントロールなど)
    - 負荷分散 (複数のサーバーが別々のリクエストに対応できるようにする)
    - 認証 (さまざまなリソースへのアクセスを制御する)
    - ログ記録 (履歴情報の保管を可能にする)  

#### HTTP の基本方針
- **HTTP はシンプル**
  - HTTP/2 で HTTP メッセージをフレームにカプセル化することにより複雑さが増しましたが、 HTTP は全体的にシンプルで人間が読めるように設計されています。 
- **HTTP は拡張可能**
  - HTTP/1.0 で導入された HTTP ヘッダーによって、プロトコルの拡張や実験が容易になっています。
- **HTTP はステートレスであるがセッションレスではない**
  - HTTP はステートレスです。同じコネクション上であっても、連続的に実行される 2 つのリクエスト間に関係性はありません。
    - ステートフルとは、システムが現在の状態を表すデータなどを保持しており、その内容を処理に反映させる方式。
  - しかし HTTP の核心がステートレスであっても、 HTTP Cookie によってステートフルなセッションを実現できます。
- **HTTP とコネクション**
  - HTTP/1.1 でパイプライン (実装が難しいことが立証されました) や持続的接続を導入しました。 Connection ヘッダーを使用して、下層の TCP コネクションを部分的に制御できます。 
  - HTTP/2 はひとつのコネクションで複数のメッセージを多重化するように進化しました。コネクションををウォーム状態に保つのに役立ち、効率が向上します。

#### HTTP が制御できること
- **キャッシュ**
  - サーバーはプロキシやクライアントに対して、何をどれだけの間キャッシュするかを指示できます。
  - クライアントは中間のキャッシュプロキシに対して、保存されている文書を無視するよう指示できます。
- **オリジン制約の緩和**
  - 同一オリジンのページだけが、ウェブページの情報すべてにアクセスできます。この制約はサーバーにとって負担になりますが、 HTTP ヘッダーでサーバー側の厳密な分割を緩和できます。
- **認証**
  - 基本的な認証は HTTP が提供しており、 WWW-Authenticate などのヘッダーを使用するか、 HTTP Cookie を使用した特別なセッションを設定する
- **プロキシとトネリング**
  - [プロキシサーバーとトンネリング](https://developer.mozilla.org/ja/docs/Web/HTTP/Proxy_servers_and_tunneling)  
  インターネットのさまざまなネットワークを移動するときに、プロキシサーバーと HTTP トンネルは、 World Wide Web 上のコンテンツへのアクセスを容易にしています。  
  プロキシには、フォワードプロキシ (またはトンネルまたはゲートウェイ) とリバースプロキシ (負荷分散、認証、復号化またはキャッシュ用のサーバーへのアクセスを制御および保護するために使用される) の2種類があります。  
  ##### HTTP トンネリング
  トンネリングはデータをカプセル化することによって、パブリックネットワークを介してプライベートネットワークデータおよびプロトコル情報を送信します。  
  HTTP トンネリングは、より低いレベルのプロトコル (TCP) を伝送するために、より高いレベル (HTTP) のプロトコルを使用しています。  
  HTTP プロトコルは CONNECT と呼ばれるリクエストメソッドを指定します。リクエストされたリソースとの双方向通信を開始し、トンネルを開くために使用することができます。  
- **セッション**
  - HTTP Cookie を使用して、リクエストとサーバーのセッションを関連付けできます。これにより HTTP がステートレスプロトコルであるにもかかわらず、セッションを作成できます。

#### HTTP のフロー
クライアントがサーバー (最終目的地のサーバーまたは中間のプロキシ) と通信したいとき、クライアントは以下の段階を踏みます。  
1. **TCP コネクションを開く:**
クライアントは新しいコネクションを開く、既存のコネクションを再使用する、あるいはサーバーに対して複数の TCP コネクションを開くことができます。  
2. **HTTP メッセージを送信する**
3. **サーバーから送信されたレスポンスを読み取る**
4. **次のリクエストのために、コネクションを閉じるか再使用する**

HTTP パイプラインが有効である場合は、最初のレスポンスが完全に返るのを待たずに複数のリクエストを送信できます。   
HTTP パイプラインは、 HTTP/2 でフレーム内にリクエストを強力に多重化する機能によって置き換えられました。  

#### HTTP メッセージ
HTTP/1.1 以前の HTTP メッセージは、人間が読むことができます。 HTTP/2 ではこれらのメッセージがバイナリ構造のフレームに埋め込まれており、ヘッダーの圧縮や多重化といった最適化が可能になりました。本来の HTTP メッセージの部分だけがこのバージョンの HTTP で送信されていても、各メッセージの意味は変わっておらず、クライアントは本来の HTTP/1.1 メッセージを (事実上) 再構成します。したがって、 HTTP/2 メッセージを HTTP/1.1 形式で理解することは役に立ちます。  

リクエスト  
![スクリーンショット 2022-01-31 17 25 24](https://user-images.githubusercontent.com/78260526/151760858-4aa917a8-bda9-4ecd-8889-bb843f1de16a.png)  
- HTTP メソッド
- 取り込むリソースのパス
  - 状況から明らかであればリソースの URL はこの要素から取り除かれます。  
  - たとえばプロトコル (http://)、ドメイン (ここでは developer.mozilla.org)、TCP ポート (ここでは 80) が取り除かれます。  
- HTTP プロトコルのバージョン
- サーバーに追加の情報を与える任意のヘッダー

レスポンス  
![スクリーンショット 2022-01-31 17 30 14](https://user-images.githubusercontent.com/78260526/151761523-c00615a7-11d6-4629-9738-78ec1ff24c1a.png)  
- 準拠する HTTP プロトコルのバージョン。
- ステータスコード。
  - リクエストが成功したか否か、およびその理由を示します。
- ステータスメッセージ。
  - ステータスコードの簡単な説明ですが、権威はありません。
- リクエストと同様の HTTP ヘッダー。
- (省略可) リソースを含む本文。

### HTTP キャッシュ
キャッシュは、提供されたリソースの複製を保存して、要求されたときに背後でその複製を提供する技術です。  
ウェブキャッシュのストア内に要求されたリソースがあるとき、キャッシュはリクエストに介入して、提供元のサーバーから再びダウンロードする代わりにキャッシュ内の複製を返します。  
キャッシュにはさまざまな種類があり、これらはプライベートキャッシュと共有キャッシュの 2 つのカテゴリーに大きく分類できます。  

- 共有キャッシュ
  - 複数のユーザーが再使用するためにレスポンスを保存するキャッシュ
- プライベートキャッシュ
  - ひとりのユーザーのためのキャッシュ

HTTP キャッシュは必須ではありませんが、キャッシュしたリソースの再使用は通常望ましいことです。  
ただし一般的な HTTP キャッシュはたいてい、GET のレスポンスのみキャッシュするよう制限されており、他のメソッドではキャッシュしません。  
キャッシュ項目の一般的な形式は以下のとおり  
- 取得要求に成功した結果: GET リクエストに対する 200 (OK) レスポンスには、HTML 文書、画像、ファイルなどのリソースが含まれています。
- 恒久的なリダイレクト: 301 (Moved Permanently) レスポンス。
- エラーレスポンス: 404 (Not Found) のページ。
- 不完全な結果: 206 (Partial Content) レスポンス。
- キャッシュのキーとして使用することが適切であると定義されていれば、GET 以外のレスポンス。

#### キャッシュを制御する
**`Cache-Control` ヘッダー**  
- キャッシュしない
  ```
  Cache-Control: no-store
  ```
- キャッシュするが再検証する
  - キャッシュした複製を渡す前に検証のため、キャッシュは生成元のサーバーにリクエストを送信します。
  ```
  Cache-Control: no-cache
  ```
- private キャッシュと public キャッシュ
  - "public" ディレクティブは、どのキャッシュでもレスポンスを保存してよいことを示します。  
    これは、通常はキャッシュできない HTTP 認証やレスポンスステータスコードを伴うページをキャッシュしなければならない時に有用です。
  - "private" はレスポンスがひとりのユーザーのためのものであり、共有キャッシュに保存してはならないことを示します。
  ```
  Cache-Control: private
  Cache-Control: public
  ```
- 有効期限
  - このヘッダーでもっとも重要なディレクティブが、リソースが陳腐化していないと考えられる最長期間を表す `"max-age=<seconds>"` です  
  ```
  Cache-Control: max-age=31536000
  ```
- 検証
  - "must-revalidate" ディレクティブを使用すると、キャッシュはリソースを使用する前に陳腐化の状態を検証しなければならず、また期限切れのリソースを使用するべきではありません。  
  ```
  Cache-Control: must-revalidate
  ```

#### 鮮度

リソースがキャッシュに保存されると、理論上は永久にキャッシュからリソースを提供することができます。  
キャッシュは有限の記憶領域ですので、アイテムは定期的に記憶領域から削除されます。この処理はキャッシュ・エビクションと呼ばれます。  

鮮度の寿命は、いくつかのヘッダーを基に計算されます。"Cache-Control: max-age=N" ヘッダーが指定された場合は、鮮度の寿命が N に等しくなります。  

そうでない場合は
```
expirationTime = responseTime + freshnessLifetime - currentAge
```
のように計算される

#### Revving を適用したリソース
キャッシュされたリソースをより多く使用すると、ウェブサイトの応答性やパフォーマンスが向上するでしょう。この最適化のために、有効期限をできるだけ遠い未来にすることが推奨されています。この方法は定期的あるいはよく更新されるリソースでも使用できますが、まれにしか更新されないリソースでは問題があります。  
ウェブ開発者は、Steve Souders 氏が revvingと呼ぶ技術を発明しました。あまり更新しないファイルは、特定の方法で命名します。その方法とは、通常はファイル名である URL にリビジョン (またはバージョン) 番号を追加することです。  
この方法ではそれぞれの新しいリビジョンのリソースが変更されないリソースであるとみなされて、通常は 1 年あるいはそれ以上先の遠い未来を有効期限にすることができます。  

#### キャッシュの検証
キャッシュされた文書の有効期限に達すると、検証または再取得を行います。キャッシュの検証は、サーバーが `strong validator` または `weak validator` を提供していれば実行できます。  
ユーザーが再読み込みボタンを押すと、再検証が発生します。キャッシュされたレスポンスに "Cache-Control: must-revalidate" ヘッダーが含まれている場合は、通常のブラウジングでも再確認が発生します。  

### Cookieについて
HTTP Cookie (ウェブ Cookie、ブラウザー Cookie) は、サーバーがユーザーのウェブブラウザーに送信する小さなデータであり、ブラウザーに保存され、その後のリクエストと共に同じサーバーへ返送されます。  
Cookie は主に、以下の 3 つの用途で使用されます。  
- セッション管理
- パーソナライゼーション
- トラッキング

#### Cookie の作成
HTTP リクエストを受け取った後、サーバーはレスポンスで Set-Cookie ヘッダーを送信することができます。通常 Cookie はブラウザーに保存され、また Cookie は同じサーバーに対して行われるリクエストと共に HTTP の Cookie ヘッダーの中で送信されます。  
単純な Cookie は次のように設定されます。  
```
Set-Cookie: <cookie-name>=<cookie-value>
```
また、そのサーバーへのその後のすべてのリクエストにおいて、ブラウザーは以前格納されたすべてのクッキーを、 Cookie ヘッダーを使用してサーバーへ送信します。  

#### Cookie の持続時間の定義
Cookie の持続時間は2通りの方法で定義することができます。
- セッション Cookie は現在のセッションが終了すると削除されます。
- 持続的 Cookie は、 Expires 属性で指定された時刻、または Max-Age で指定された期間が経過した後に削除されます。 

#### Cookie へのアクセス制限
クッキーが安全に送信され、意図しない第三者やスクリプトからアクセスされないようにするには、 `Secure 属性`と `HttpOnly 属性`の2つの方法があります。  
- Secure 属性がついたクッキーは HTTPS プロトコル上の暗号化されたリクエストでのみサーバーに送信され、安全でない HTTP では決して送信されないため、中間者攻撃者が簡単にアクセスすることはできません。(URL に http: を含む) 安全でないサイトは、 Secure 属性を使用してクッキーを設定することができません。 
- HttpOnly 属性を持つクッキーは、JavaScript の Document.cookie API にはアクセスできません。サーバーに送信されるだけです。例えば、サーバー側のセッションを持続させるクッキーは JavaScript が利用する必要はないので、 HttpOnly 属性をつけるべきです。この予防策は、クロスサイトスクリプティング (XSS) 攻撃を緩和するのに役立ちます。  

#### Cookie の送信先の定義
Domain および Path 属性は、Cookie のスコープ、つまり Cookie を送信する対象の URL を定義します。  

- `Domain 属性`
  - Domain 属性は、Cookie を受信することができるホストを指定します。指定されていない場合は、既定でクッキーを設定したのと同じオリジンとなり、サブドメインは除外されます。 Domain が指定された場合、サブドメインは常に含まれます。したがって、 Domain を指定すると省略時よりも制限が緩和されます。  
- `Path 属性`
  - Path 属性は、 Cookie ヘッダーを送信するためにリクエストされた URL の中に含む必要がある URL のパスを示します。
  例えば、Path=/docs を設定すると、以下のパスに一致します。

  ```
  /docs
  /docs/Web/
  /docs/Web/HTTP
  ```
- `SameSite 属性`
  - SameSite 属性により、サーバーがオリジン間リクエスト (ここでサイトは登録可能なドメインによって定義されます) と一緒にクッキーを送るべきではないことを要求することができます。
  - これは、クロスサイトリクエストフォージェリ攻撃 (CSRF) に対していくらかの防御となります。


#### セキュリティ
> 情報をクッキーに保存するときは、すべてのクッキーの値がエンドユーザーから見え、変更できることを理解しておいてください。アプリケーションによっては、サーバー側で検索される不透明な識別子を使用するか、 JSON ウェブトークンのような代替の認証/機密性メカニズムを調べたほうが良いかもしれません。

クッキーへの攻撃を緩和する方法には次のようなものがあります。
- HttpOnly 属性を使用して、 JavaScript からクッキーの値にアクセスすることを防ぎます。
- 機密情報 (認証を示す場合など) のために使用されたクッキーは、持続時間を短く、 SameSite 属性を Strict または Lax に設定してください。 

#### トラッキングとプライバシー
Cookie はドメインに関連付けられます。このドメインが閲覧しているページのドメインと同じである場合、そのクッキーは、ファーストパーティ Cookie と呼ばれます。    
ドメインが異なる場合は、サードパーティ Cookie と呼びます。  

**Cookie に関する規制**  
クッキーの使用を対象とした法規制には、以下のようなものがあります。
- EU の 一般データ保護規則 (GDPR)
- EU の ePrivacy 指令
- カリフォルニア州消費者プライバシー法

これらの規制の要件には次のようなものがあります。
- サイトがクッキーを使用することをユーザーに通知する。
- ユーザーが一部またはすべてのクッキーをオプトアウトできるようにする。
- ユーザーがクッキーを受け取らなくても、サービスの大部分を利用できるようにする。


### オリジン間リソース共有 (CORS)
オリジン間リソース共有 (Cross-Origin Resource Sharing, CORS) は、追加の HTTP ヘッダーを使用して、あるオリジンで動作しているウェブアプリケーションに、異なるオリジンにある選択されたリソースへのアクセス権を与えるようブラウザーに指示するための仕組み  
ウェブアプリケーションは、自分とは異なるオリジン (ドメイン、プロトコル、ポート番号) にあるリソースをリクエストするとき、オリジン間 HTTP リクエストを実行します。  

セキュリティ上の理由から、ブラウザーは、スクリプトによって開始されるオリジン間 HTTP リクエストを制限しています。例えば、 XMLHttpRequestや Fetch API は同一オリジンポリシー (same-origin policy) に従います。つまり、これらの API を使用するウェブアプリケーションは、そのアプリケーションが読み込まれたのと同じオリジンに対してのみリソースのリクエストを行うことができ、それ以外のオリジンからの場合は正しい CORS ヘッダーを含んでいることが必要です。  

#### アクセス制御シナリオの例
単純リクエストは、以下のすべての条件を満たすもの  
- 許可されているメソッドのうちのいずれかであること。
  - GET
  - HEAD
  - POST
- Fetch 仕様書で CORS セーフリストリクエストヘッダーとして定義されている以下のヘッダーだけです。
  - Accept
  - Accept-Language
  - Content-Language
  - Content-Type


**プリフライトリクエスト**  
単純リクエストとは異なり、「プリフライト」リクエストは始めに OPTIONS メソッドによる HTTP リクエストを他のドメインにあるリソースに向けて送り、実際のリクエストを送信しても安全かどうかを確かめます。  
サイト間リクエストがユーザーデータに影響を与える可能性があるような場合に、このようにプリフライトを行います。  
  
単純リクエスト → 無条件にリクエストを送信でき、レスポンスヘッダーによって、JavaScriptがリソースを受け取れるかを判断する。  
単純リクエスト以外 → プリフライトリクエスト(Preflight)で事前にリクエスト送信の許可を確認して、その後にリクエストを送信する   

[【CORS】JavaScriptにおけるCORSやPreflightを理解する](https://it-web-life.com/javascript_cors_preflight/)  

#### 資格情報を含むリクエスト
XMLHttpRequest や Fetch と CORS の両方によって明らかになる最も興味深い機能は、HTTP クッキーと HTTP 資格情報によってわかる「資格情報を含む」リクエストを作成することができることです。既定では、サイト間の XMLHttpRequest または Fetch の呼び出しにおいて、ブラウザーは資格情報を送信しません。 XMLHttpRequest オブジェクトまたは Request のコンストラクターの呼び出し時に、特定のフラグを設定する必要があります。  

資格情報付きリクエストに返答する場合、

- サーバーは Access-Control-Allow-Origin ヘッダーで `"*"` ワイルドカードを指定してはならず、 Access-Control-Allow-Origin: https://example.com のように、明示的にオリジンを指定しなければなりません。
- サーバーは Access-Control-Allow-Headers ヘッダーで `"*"` ワイルドカードを指定してはならず、 Access-Control-Allow-Headers: X-PINGOTHER, Content-Type のように、明示的にヘッダー名を指定しなければなりません。
- サーバーは Access-Control-Allow-Methods ヘッダーで `"*"` ワイルドカードを指定してはならず、 Access-Control-Allow-Methods: POST, GET のように、明示的にメソッド名を指定しなければなりません。

#### HTTP レスポンスヘッダー
`Access-Control-Allow-Origin`  
Access-Control-Allow-Origin は、リソースへのアクセスを許可するオリジンをブラウザーに伝えるための単一のオリジン、または — 資格情報を含まないリクエストにおいては — どのオリジンにもリソースへのアクセスを許可することをブラウザーに伝えるワイルドカード `"*"` のどちらかを指定することができます。  
```
Access-Control-Allow-Origin: https://mozilla.org
Vary: Origin
```

サーバーがワイルドカード `"*"` ではなく (ホワイトリストの一部としてリクエストするオリジンに基づいて動的に変更される可能性がある) 単一のオリジンを指定した場合は、サーバーは Origin を Vary レスポンスヘッダーに含めて、サーバーのレスポンスが Origin リクエストヘッダーの値によって変化することもクライアントに示してください。  

`Access-Control-Expose-Headers`  
指定されたヘッダーをブラウザー内の JavaScript (getResponseHeader() など) からアクセスできる許可リストに加えます。  

```
Access-Control-Expose-Headers: X-My-Custom-Header, X-Another-Custom-Header
```

`Access-Control-Max-Age`  
このヘッダーはプリフライトリクエストの結果をキャッシュしてよい時間を示します。  
```
Access-Control-Max-Age: <delta-seconds>
```
delta-seconds 引数は、結果をキャッシュしてよい時間を秒単位で示します。

`Access-Control-Allow-Credentials`  
credentials フラグが true である場合に、リクエストへのレスポンスを開示してよいか否かを示します。プリフライトリクエストのレスポンスの一部として用いられたときは、実際のリクエストで資格情報を使用してよいか否かを示します。単純な GET リクエストはプリフライトを行いませんので、リソースへのリクエストが資格情報付きで行われた場合にリソースと共にこのヘッダーを返さなければ、ブラウザーがそのレスポンスを無視し、ウェブのコンテンツが返されないことに注意してください。  
```
Access-Control-Allow-Credentials: true
```

`Access-Control-Allow-Methods`  
リソースへのアクセス時に許可するメソッドを指定します。これはプリフライトリクエストのレスポンスで用いられます。  

`Access-Control-Allow-Headers`  
プリフライトリクエストへのレスポンスで使用され、実際のリクエストを行う際に使用される HTTP ヘッダーを示します。  

#### HTTP リクエストヘッダー
HTTP リクエストを発行する際、オリジン間リソース共有機能を利用するためにクライアントが使用できるヘッダー  
`Origin`  
Origin ヘッダーはサイト間のアクセスリクエストやプリフライトリクエストのオリジンを示します。  
origin は、リクエストを開始したサーバーを示す URL です。ここにパス情報は含めず、サーバー名だけにします。  

Note: origin の値は null にすることができます。

なお、すべてのアクセス制御リクエストにおいて、 Origin ヘッダーは常に送信されます。

`Access-Control-Request-Method`  
プリフライトリクエストを発信する際に、実際のリクエストを行う際に使用する HTTP メソッドをサーバーに知らせるために使用します。  

`Access-Control-Request-Headers`  
プリフライトリクエストを発行する際に、実際のリクエストを行う際に (setRequestHeader() などによって) 使用する HTTP ヘッダーをサーバーに知らせるために使用します。



