## やったこと
git rebaseと styled-componentsについて

### git rebaseについて
[公式DOC](https://git-scm.com/book/ja/v2/Git-%E3%81%AE%E3%83%96%E3%83%A9%E3%83%B3%E3%83%81%E6%A9%9F%E8%83%BD-%E3%83%AA%E3%83%99%E3%83%BC%E3%82%B9)  
[Git rebase](https://www.atlassian.com/ja/git/tutorials/rewriting-history/git-rebase)  
Git には、あるブランチの変更を別のブランチに統合するための方法が大きく分けて二つあります。 **merge** と **rebase** です。  
rebase は、1 つのブランチから別のブランチへの変更を統合することを専門とした、2 つの Git ユーティリティの 1 つです。もう 1 つの変更統合ユーティリティは git merge です。マージは常に、変更レコードを先へ動かします。代わりに、rebase には強力な履歴書き換え機能を備えています。  

コンテンツという観点において、リベースは、あるコミットから他のコミットにブランチを移動させ、別のコミットからブランチを作成したように見せています。  
しかし Git の内部では、**新たなコミットを生成してそれを移動先のベースコミットに適用する**ことによってこれを行なっています。  
ここでは、**ブランチそのものは同じものに見えていても、それを構成するコミットは全く異なる**ことを理解することが重要です。   

#### Git リベース標準モードと Git リベースのインタラクティブ モード
Git rebase interactive は、git rebase が -- i 引数を受け入れます。これは、「インタラクティブ」を表します。引数が指定されていない場合、コマンドは標準モードで実行します。  
Git rebase 標準モードは、現在の作業ブランチのコミットを自動的に取得し、渡されたブランチの HEAD に適用します。  
git rebase を -i フラグで実行するとインタラクティブなリベース セッションが開始されます。インタラクティブなリベースでは、すべてのコミットをそのまま新しい ベースに移動するのではなく、対象となる個々のコミットの改変が可能です。これを使用して、既存の一連のコミットの削除、分割、改変を行って履歴を整理することができます。これはちょうど、`Git commit --amend` の強化版と言えます。  

##### `git commit --amend`
git commit --amend コマンドは、直前のコミットを変更する最も便利な方法です。これを使用することで全く新しいコミットを作成する代わりに、ステージングされた変更を前のコミットと組み合わせることができます。また、スナップショットを変更せずに、前のコミット メッセージを単純に変更する際にも使用されます。しかし、改変では、直前のコミットが変更されるだけでなく、全体が置き換えられます。つまり、修正されたコミットは独自の ref を持つ新しいエンティティとなります。Git にとっては全く新しいコミットのように見えます (以下の図ではアスタリスク (`*`) を使用して視覚化されています)。  

![スクリーンショット 2022-02-09 14 45 32](https://user-images.githubusercontent.com/78260526/153129423-89830fa1-9f34-4be4-bd6b-eaade9852ae2.png)  

レビューを行うには、git commit --amend を使用すると、直前のコミットへ移動して、そこに新しいステージングされた変更を追加します。  

インタラクティブなリベースセッションを使用して現在のブランチを  にリベースするコマンドです。このコマンドを実行すると、エディターが開き、リベースする個々のコミットに対するコマンド (下で説明します) の入力が可能となります。ここでのコマンドは、個々のコミットを新しいベースに移動する方法を指定します。また、エディターにおけるコミットの並びを直接編集することによりコミットの順番を並び替えることもできます。  

インタラクティブなリベースの真価は、書き換えられた main ブランチの履歴で確認できます。事情を知らない者にとっては、開発者が有能で最小限のコミットを一度ずつ実行しただけで開発を完了できたかのように見えます。  

#### rebase の高度な用途
```
git rebase --onto <newbase> <oldbase>
```
--onto 特定の ref を rebase の最後に渡せる、より強力なフォームまたは rebase を実現します。  
```
 o---o---o---o---o  main
      \
       o---o---o---o---o  featureA
            \
             o---o---o  featureB
```
このようなリポジトリの場合
featureB は featureA に基づいていますが featureA の変更に依存しておらず、main からの分岐に過ぎないことがわかります。  
```
git rebase --onto main featureA featureB
```
このコマンドを実行すると、このようになる
```
                  o---o---o  featureB
                 /
o---o---o---o---o  main
 \
  o---o---o---o---o  featureA
```







